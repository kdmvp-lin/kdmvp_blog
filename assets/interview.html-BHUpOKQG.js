import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as a,g as n}from"./app-DGYQivyt.js";const t={},l=n('<h1 id="_1-redis" tabindex="-1"><a class="header-anchor" href="#_1-redis"><span>1.Redis</span></a></h1><h2 id="_1-1-五个基本类型" tabindex="-1"><a class="header-anchor" href="#_1-1-五个基本类型"><span>1.1 五个基本类型</span></a></h2><ul><li>String（字符串） 应用场景：共享session、分布式锁，计数器、限流</li><li>Hash（哈希） 应用场景：缓存用户信息</li><li>List（列表） 应用场景：消息队列，文章列表</li><li>Set（集合） 应用场景：用户标签,生成随机数抽奖、社交需求</li><li>zset（有序集合） 应用场景：排行榜，社交需求（如用户点赞）</li></ul><h2 id="_1-2速度快的原因" tabindex="-1"><a class="header-anchor" href="#_1-2速度快的原因"><span>1.2速度快的原因</span></a></h2><h3 id="_1-2-1基于内存存储" tabindex="-1"><a class="header-anchor" href="#_1-2-1基于内存存储"><span>1.2.1基于内存存储</span></a></h3><p>基于内存实现的数据库，省去I/O的消耗 （redis可以持久化防止数据丢失）</p><h3 id="_1-2-2高效的数据结构" tabindex="-1"><a class="header-anchor" href="#_1-2-2高效的数据结构"><span>1.2.2高效的数据结构</span></a></h3><p>Redis 作为 K-V 型内存数据库，所有的键值就是用字典来存储，事件复杂度为O（1）</p><ul><li>字符串不是传统的char[]而是SDS简单动态字符串</li><li>有序集合采用的是跳跃表</li></ul><h3 id="_1-2-3合理的数据编码" tabindex="-1"><a class="header-anchor" href="#_1-2-3合理的数据编码"><span>1.2.3合理的数据编码</span></a></h3><p>每种基本类型，可能对多种数据结构，因此针对每个存储值不同编码方式也不同</p><h3 id="_1-2-4合理的线程模型" tabindex="-1"><a class="header-anchor" href="#_1-2-4合理的线程模型"><span>1.2.4合理的线程模型</span></a></h3><p>多路I/O复用，一个线程可以监视多个文件句柄</p><h3 id="_1-2-5虚拟内存机制" tabindex="-1"><a class="header-anchor" href="#_1-2-5虚拟内存机制"><span>1.2.5虚拟内存机制</span></a></h3><p>暂时把不经常访问的数据(冷数据)从内存交换到磁盘中</p><h2 id="_1-3缓存穿透问题" tabindex="-1"><a class="header-anchor" href="#_1-3缓存穿透问题"><span>1.3缓存穿透问题</span></a></h2><p>下面是redis读取数据的流程</p><p>![[Pasted image 20231009154301.png]] 缓存穿透就是说，查询一个一定不存在的数据，那么都是需要穿透到数据库中去查找，这样就进而给数据库带来压力。</p><p>原因：业务设计不合理、非法假数据的请求 解决方法：在API入口，对参数进行校验，过滤非法值</p><h2 id="_1-4缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_1-4缓存雪崩"><span>1.4缓存雪崩</span></a></h2><p>缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机</p><p>解决方法：可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值+一个较小的随机值。或者采用redis集群</p><h2 id="_1-5缓存击穿问题" tabindex="-1"><a class="header-anchor" href="#_1-5缓存击穿问题"><span>1.5缓存击穿问题</span></a></h2><p>指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db</p><p>缓存雪奔是指数据库压力过大甚至down机，缓存击穿只是大量并发请求到了DB数据库层面。可以认为击穿是缓存雪奔的一个子集 解决方法：热点数据快要过期时，异步线程去更新和设置过期时间。</p><h2 id="_1-6redis持久化" tabindex="-1"><a class="header-anchor" href="#_1-6redis持久化"><span>1.6redis持久化</span></a></h2><h3 id="_1-6-1rdb" tabindex="-1"><a class="header-anchor" href="#_1-6-1rdb"><span>1.6.1RDB</span></a></h3><p>把内存数据以快照的形式保存到磁盘上</p><p>RDB持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个<code>dump.rdb</code>文件，Redis 重启的时候，通过加载<code>dump.rdb</code>文件来恢复数据。</p><p><strong>RDB 的优点</strong></p><ul><li>适合大规模的数据恢复场景，如备份，全量复制等</li></ul><p><strong>RDB缺点</strong></p><ul><li>没办法做到实时持久化/秒级持久化。</li><li>新老版本存在RDB格式兼容问题</li></ul><h3 id="_1-6-2aof" tabindex="-1"><a class="header-anchor" href="#_1-6-2aof"><span>1.6.2AOF</span></a></h3><p>采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。</p><p><strong>AOF的优点</strong></p><ul><li>数据的一致性和完整性更高</li></ul><p><strong>AOF的缺点</strong></p><ul><li>AOF记录的内容越多，文件越大，数据恢复变慢。</li></ul><h1 id="_2-消息队列" tabindex="-1"><a class="header-anchor" href="#_2-消息队列"><span>2.消息队列</span></a></h1><h2 id="_2-1什么是消息队列" tabindex="-1"><a class="header-anchor" href="#_2-1什么是消息队列"><span>2.1什么是消息队列</span></a></h2><p>消息队列理解为一个<strong>使用队列来通信</strong>的组件。它的本质，就是个<strong>转发器</strong>，包含<strong>发消息、存消息、消费消息</strong>的过程。最简单的消息队列模型如下： ![[Pasted image 20231009160025.png]]</p><h2 id="_2-2为什么使用消息队列" tabindex="-1"><a class="header-anchor" href="#_2-2为什么使用消息队列"><span>2.2为什么使用消息队列</span></a></h2><ul><li>应用解耦 应用场景：下单扣库存，用户下单后，订单系统去通知库存系统扣减。传统的做法就是订单系统直接调用库存系统,如果库存系统无法访问，下单就会失败，订单和库存系统存在耦合关系。如果中间加了一个消息队列，订单系统只需要把把订单存到队列中就已经下单成功，如果库存系统坏了也没关系，等修复完再订阅数据。 ![[Pasted image 20231009160745.png]]</li><li>流量削峰 秒杀系统每秒最多可以处理<code>2k</code>个请求，每秒却有<code>5k</code>的请求过来，可以引入消息队列，秒杀系统每秒从消息队列拉2k请求处理就行，防止消息积压问题，可以为消息队列设置一个最大长度</li><li>异步处理 注册信息入库是30ms，发短信、邮件也是30ms，三个动作<strong>串行执行</strong>的话，会比较耗时，响应90ms，采用并行执行的方式，可以减少响应时间。注册信息入库后，同时异步发短信和邮件。如何实现异步呢，用消息队列即可，就是说，注册信息入库成功后，写入到消息队列（这个一般比较快，如只需要3ms），然后异步读取发邮件和短信。 ![[Pasted image 20231009161639.png]] ![[Pasted image 20231009161648.png]]</li><li>消息通讯 消息队列内置了高效的通信机制，可用于消息通讯。如实现点对点消息队列、聊天室等。</li><li>远程调用</li></ul><h2 id="_2-3消息队列如何保证消息的顺序性" tabindex="-1"><a class="header-anchor" href="#_2-3消息队列如何保证消息的顺序性"><span>2.3消息队列如何保证消息的顺序性</span></a></h2><p>假设生产者先后产生了两条消息，分别是下单消息（M1），付款消息（M2），M1比M2先产生，由于网络延迟又可能M2比M1先到，可以将M1、M2发送到同一个Server上，当M1发送完收到ack后，M2再发送</p>',46),s=[l];function r(d,h){return i(),a("div",null,s)}const c=e(t,[["render",r],["__file","interview.html.vue"]]),_=JSON.parse(`{"path":"/posts/interview/interview.html","title":"1.Redis","lang":"zh-CN","frontmatter":{"description":"1.Redis 1.1 五个基本类型 String（字符串） 应用场景：共享session、分布式锁，计数器、限流 Hash（哈希） 应用场景：缓存用户信息 List（列表） 应用场景：消息队列，文章列表 Set（集合） 应用场景：用户标签,生成随机数抽奖、社交需求 zset（有序集合） 应用场景：排行榜，社交需求（如用户点赞） 1.2速度快的原因 1...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/interview/interview.html"}],["meta",{"property":"og:site_name","content":"kdmvp's\\tblog"}],["meta",{"property":"og:title","content":"1.Redis"}],["meta",{"property":"og:description","content":"1.Redis 1.1 五个基本类型 String（字符串） 应用场景：共享session、分布式锁，计数器、限流 Hash（哈希） 应用场景：缓存用户信息 List（列表） 应用场景：消息队列，文章列表 Set（集合） 应用场景：用户标签,生成随机数抽奖、社交需求 zset（有序集合） 应用场景：排行榜，社交需求（如用户点赞） 1.2速度快的原因 1..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-18T06:44:44.000Z"}],["meta",{"property":"article:author","content":"林伟强"}],["meta",{"property":"article:modified_time","content":"2024-04-18T06:44:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.Redis\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-18T06:44:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"林伟强\\"}]}"]]},"headers":[{"level":2,"title":"1.1 五个基本类型","slug":"_1-1-五个基本类型","link":"#_1-1-五个基本类型","children":[]},{"level":2,"title":"1.2速度快的原因","slug":"_1-2速度快的原因","link":"#_1-2速度快的原因","children":[{"level":3,"title":"1.2.1基于内存存储","slug":"_1-2-1基于内存存储","link":"#_1-2-1基于内存存储","children":[]},{"level":3,"title":"1.2.2高效的数据结构","slug":"_1-2-2高效的数据结构","link":"#_1-2-2高效的数据结构","children":[]},{"level":3,"title":"1.2.3合理的数据编码","slug":"_1-2-3合理的数据编码","link":"#_1-2-3合理的数据编码","children":[]},{"level":3,"title":"1.2.4合理的线程模型","slug":"_1-2-4合理的线程模型","link":"#_1-2-4合理的线程模型","children":[]},{"level":3,"title":"1.2.5虚拟内存机制","slug":"_1-2-5虚拟内存机制","link":"#_1-2-5虚拟内存机制","children":[]}]},{"level":2,"title":"1.3缓存穿透问题","slug":"_1-3缓存穿透问题","link":"#_1-3缓存穿透问题","children":[]},{"level":2,"title":"1.4缓存雪崩","slug":"_1-4缓存雪崩","link":"#_1-4缓存雪崩","children":[]},{"level":2,"title":"1.5缓存击穿问题","slug":"_1-5缓存击穿问题","link":"#_1-5缓存击穿问题","children":[]},{"level":2,"title":"1.6redis持久化","slug":"_1-6redis持久化","link":"#_1-6redis持久化","children":[{"level":3,"title":"1.6.1RDB","slug":"_1-6-1rdb","link":"#_1-6-1rdb","children":[]},{"level":3,"title":"1.6.2AOF","slug":"_1-6-2aof","link":"#_1-6-2aof","children":[]}]},{"level":2,"title":"2.1什么是消息队列","slug":"_2-1什么是消息队列","link":"#_2-1什么是消息队列","children":[]},{"level":2,"title":"2.2为什么使用消息队列","slug":"_2-2为什么使用消息队列","link":"#_2-2为什么使用消息队列","children":[]},{"level":2,"title":"2.3消息队列如何保证消息的顺序性","slug":"_2-3消息队列如何保证消息的顺序性","link":"#_2-3消息队列如何保证消息的顺序性","children":[]}],"git":{"createdTime":1713422684000,"updatedTime":1713422684000,"contributors":[{"name":"kdmvp-lin","email":"1561790129@qq.com","commits":1}]},"readingTime":{"minutes":4.94,"words":1482},"filePathRelative":"posts/interview/interview.md","localizedDate":"2024年4月18日","excerpt":"\\n<h2>1.1 五个基本类型</h2>\\n<ul>\\n<li>String（字符串）\\n应用场景：共享session、分布式锁，计数器、限流</li>\\n<li>Hash（哈希）\\n应用场景：缓存用户信息</li>\\n<li>List（列表）\\n应用场景：消息队列，文章列表</li>\\n<li>Set（集合）\\n应用场景：用户标签,生成随机数抽奖、社交需求</li>\\n<li>zset（有序集合）\\n应用场景：排行榜，社交需求（如用户点赞）</li>\\n</ul>\\n<h2>1.2速度快的原因</h2>\\n<h3>1.2.1基于内存存储</h3>\\n<p>基于内存实现的数据库，省去I/O的消耗\\n（redis可以持久化防止数据丢失）</p>","autoDesc":true}`);export{c as comp,_ as data};
